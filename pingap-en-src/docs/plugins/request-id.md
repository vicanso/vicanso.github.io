---
sidebar_position: 97
title: Request ID
description: Attaches a unique identifier to each incoming request for distributed tracing, log correlation, and troubleshooting, a key part of enhancing system observability.
---

# Request ID Plugin

The `request-id` plugin is an observability plugin whose core function is to ensure that **every** request passing through Pingap has a **unique identifier**.

## Feature Introduction

In complex distributed systems or microservices architectures, a single user request may flow through multiple services. Without a unified identifier to link these calls together, tracing and locating the point of failure becomes extremely difficult when issues arise.

The `request-id` plugin solves this problem in the following way:
1.  **Check Incoming Request**: The plugin first checks if a request ID **already exists** in the request headers (for example, generated by another upstream gateway or the client). If it exists, the plugin will **respect and use** this ID to ensure the integrity of the trace.
2.  **Generate New ID**: If a request ID is **not present** in the headers, the plugin will automatically **generate a new unique ID** based on the algorithm you configure.
3.  **Inject Request Header**: The plugin will inject this ID (whether it's the existing one or a newly generated one) into a specified HTTP request header (defaulting to `X-Request-ID`) before forwarding the request to the upstream service.

This way, from the gateway to all backend services, you can use the same ID to correlate logs and trace call chains, allowing for rapid problem diagnosis.

## Use Cases

* **Distributed Tracing**: This is the most critical use case. All services (gateway, business APIs, database proxies, etc.) should record the `X-Request-ID` in their logs. When an issue occurs, you can simply filter by this ID to get the complete log record of that request across all services.
* **Troubleshooting and Debugging**: When a user reports an issue, you can ask them to find the `X-Request-ID` of the corresponding failed request in their browser's developer tools. With this ID, you can pinpoint the relevant error information in a massive volume of logs.
* **Correlating Logs and Metrics**: By using the request ID as a label in logs and monitoring metrics (like Prometheus), you can correlate specific log entries with high-level performance metrics for more in-depth analysis.

## Configuration Parameters

Configuration is done in the `plugin.request-id.toml` file.

| Parameter     | Type    | Required | Default          | Description                                                                                                                                                                                                                                                            |
| :------------ | :------ | :------- | :--------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `algorithm`   | String  | No       | `"uuid_v7"`      | The algorithm used when generating a new ID. Possible values are:<br/>• **`"uuid_v7"`**: Generates a time-based UUID v7. Its ordered nature is very friendly for database indexing and log sorting.<br/>• **`"nanoid"`**: Generates a shorter, URL-safe random string. |
| `size`        | Integer | No       | `8`              | Only effective when `algorithm` is `"nanoid"`. Specifies the length of the generated ID.                                                                                                                                                                               |
| `header_name` | String  | No       | `"X-Request-ID"` | The name of the HTTP request header used to carry the request ID. You can customize this according to your team's standards (e.g., `Trace-Id`).                                                                                                                        |

---

## Complete Example

**Goal**: Add a unique request ID to all API requests passing through Pingap for subsequent log tracing. We will choose the `nanoid` algorithm to generate a 12-character ID and use `X-Trace-ID` as the header name.

1.  **Configure the plugin (`plugin.request-id-api.toml`)**:
    ```toml
    # Use the nanoid algorithm
    algorithm = "nanoid"
    
    # Set the generated ID length to 12
    size = 12

    # Use a custom header name
    header_name = "X-Trace-ID"
    ```

2.  **Apply the plugin in a Location (`location.toml`)**:
    ```toml
    # location.toml
    [locations.route-for-api]
    # Match all API requests
    path = "/api/"
    upstream = "api-backend"
    plugins = [
        # Place the Request ID plugin first to ensure the ID is generated as early as possible
        "request-id-api",
        # ... other plugins
    ]
    ```

### Access Effects

* **Scenario 1: A client initiates a new request**
    * A client sends `GET /api/users`.
    * Pingap's `request-id-api` plugin checks and finds no `X-Trace-ID` in the request headers.
    * The plugin generates a new 12-character nanoid, for example, `Abc123Def456`.
    * The plugin **adds** the `X-Trace-ID: Abc123Def456` header to the request.
    * Finally, the `api-backend` service receives the request containing this `X-Trace-ID` header and can record it in its logs.

* **Scenario 2: The request already includes an ID**
    * Another upstream service (like a frontend gateway) has already generated an ID and sends a request to Pingap with the header `X-Trace-ID: upstream-generated-id-789`.
    * Pingap's `request-id-api` plugin checks and finds that the `X-Trace-ID` header **already exists**.
    * The plugin will **not** generate a new ID, but will use the existing `upstream-generated-id-789`.
    * The value of `X-Trace-ID` in the request received by the `api-backend` service will still be `upstream-generated-id-789`, maintaining the continuity of the trace.