---
sidebar_position: 97
title: 请求 ID (Request ID)
description: 为每个进入的请求附加一个唯一的标识符，用于实现分布式链路追踪、日志关联和问题排查，是提升系统可观测性的关键一环。
---

# 请求 ID (Request ID) 插件

`request-id` 插件是一个可观测性插件，它的核心功能是确保**每一个**通过 Pingap 的请求都拥有一个**唯一的标识符**。

## 功能简介

在复杂的分布式系统或微服务架构中，一个用户请求可能会流经多个服务。如果没有一个统一的标识符来串联这些调用，那么在出现问题时，追踪和定位故障点将变得异常困难。

`request-id` 插件通过以下方式解决了这个问题：
1.  **检查传入请求**：插件会首先检查请求头中是否**已存在**一个请求 ID（例如，由上游的另一个网关或客户端生成）。如果存在，插件会**尊重并沿用**这个 ID，确保链路的完整性。
2.  **生成新 ID**：如果请求头中**不存在**请求 ID，插件会根据您配置的算法自动**生成一个新的唯一 ID**。
3.  **注入请求头**：插件会将这个 ID（无论是沿用的还是新生成的）注入到一个指定的 HTTP 请求头中（默认为 `X-Request-ID`），然后才将请求转发给上游服务。

这样，从网关到所有后端服务，您都可以通过这同一个 ID 来关联日志、追踪调用链，从而快速定位问题。

## 使用场景

* **分布式链路追踪**：这是最核心的场景。所有服务（网关、业务 API、数据库代理等）的日志都应记录 `X-Request-ID`。当出现问题时，您只需根据这个 ID 就能筛选出该请求在所有服务中的完整日志记录。
* **问题排查与调试**：当用户报告问题时，您可以让他在前端开发者工具中找到对应失败请求的 `X-Request-ID`。有了这个 ID，您就能在海量日志中精确定位到相关的错误信息。
* **日志与指标关联**：将请求 ID 作为日志和监控指标（如 Prometheus）的标签 (label)，可以将具体的日志条目与宏观的性能指标关联起来，进行更深入的分析。

## 配置参数

在 `plugins.request-id.toml` 文件中进行配置。

| 参数          | 类型    | 是否必需 | 默认值           | 说明                                                                                                                                                                                            |
| :------------ | :------ | :------- | :--------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `algorithm`   | String  | 否       | `"uuid_v7"`      | 生成新 ID 时使用的算法。可选值为：<br/>• **`"uuid_v7"`**: 生成一个基于时间的 UUID v7。有序的特性使其对数据库索引和日志排序非常友好。<br/>• **`"nanoid"`**: 生成一个更短、URL 安全的随机字符串。 |
| `size`        | Integer | 否       | `8`              | 仅当 `algorithm` 为 `"nanoid"` 时生效，用于指定生成 ID 的长度。                                                                                                                                 |
| `header_name` | String  | 否       | `"X-Request-ID"` | 用于携带请求 ID 的 HTTP 请求头名称。您可以根据团队的规范（如 `Trace-Id`）进行自定义。                                                                                                           |

---

## 完整示例

**目标**：为所有通过 Pingap 的 API 请求添加一个唯一的请求 ID，以便于后续的日志追踪。我们选择使用 `nanoid` 算法生成一个 12 位的 ID，并使用 `X-Trace-ID` 作为请求头名称。

1.  **配置插件 (`plugins.request-id-api.toml`)**:
    ```toml
    # 使用 nanoid 算法
    algorithm = "nanoid"
    
    # 设置生成的 ID 长度为 12
    size = 12

    # 使用自定义的请求头名称
    header_name = "X-Trace-ID"
    ```

2.  **在 Location 中应用插件 (`location.toml`)**:
    ```toml
    # location.toml
    [locations.route-for-my-app]
    # 匹配所有 API 请求
    path = "/api/"
    upstream = "api-backend"
    plugins = [
        # 将 Request ID 插件放在最前面，确保尽早生成 ID
        "request-id-api",
        # ... 其他插件
    ]
    ```

### 访问效果

* **场景一：客户端发起一个新请求**
    * 客户端发送 `GET /api/users`。
    * Pingap 的 `request-id-api` 插件检查发现请求头中没有 `X-Trace-ID`。
    * 插件生成一个新的、长度为 12 的 nanoid，例如 `Abc123Def456`。
    * 插件将 `X-Trace-ID: Abc123Def456` 这个请求头**添加**到请求中。
    * 最终，`api-backend` 服务收到的请求中将包含这个 `X-Trace-ID` 头，并可以在其日志中记录下来。

* **场景二：请求已包含 ID**
    * 另一个上游服务（如前端网关）已经生成了一个 ID，并发送了一个带 `X-Trace-ID: upstream-generated-id-789` 的请求到 Pingap。
    * Pingap 的 `request-id-api` 插件检查发现请求头中**已存在** `X-Trace-ID`。
    * 插件**不会**生成新的 ID，而是直接沿用 `upstream-generated-id-789`。
    * `api-backend` 服务收到的请求中 `X-Trace-ID` 的值依然是 `upstream-generated-id-789`，保持了链路的连贯性。