---
sidebar_position: 84
title: 缓存 (Cache)
description: 通过缓存上游服务的响应，大幅提升高频访问接口的性能、降低延迟，并有效减轻后端服务负载。支持内存与文件双层缓存、缓存驱逐、缓存刷新等高级功能。
---

# 缓存 (Cache) 插件

`cache` 插件是一个功能强大且高度可配置的 HTTP 缓存插件。它能将来自上游服务的响应存储在 Pingap 中，当后续有相同的请求到达时，可以直接从缓存中返回响应，而无需再次请求后端服务。



## 功能简介

该插件实现了完整的 HTTP 缓存逻辑，并提供了多种高级功能以适应复杂的生产环境需求：

* **智能缓存策略**: 遵循 HTTP `Cache-Control` 响应头（如 `max-age`, `private`, `no-store`），自动判断响应是否可以被缓存以及缓存多久。
* **多种缓存后端**: 支持将缓存同时存储在**内存**和**文件系统**中，兼顾了访问速度与存储容量。
* **缓存驱逐 (Eviction)**: 当内存缓存达到上限时，采用 LRU (Least Recently Used) 算法自动淘汰最久未使用的缓存项，文件缓存无需启用缓存驱逐。
* **缓存刷新 (Purge)**: 支持通过发送一个特殊的 `PURGE` HTTP 请求来**主动清除**指定的缓存项，并可通过 IP 白名单进行权限控制。
* **缓存击穿防护 (Lock)**: 在高并发场景下，对于同一个资源的首次请求，只有一个请求会被允许回源，其他请求会等待第一个请求的结果，有效防止了缓存失效瞬间大量请求打穿到后端的问题（也称“缓存惊群”或“狗桩效应”）。
* **多样化缓存**: 例如可以启用压缩插件，其会将`Accept-Encoding`设置为缓存key的一部分，为同一个 `URL` 存储不同的压缩缓存版本，减少数据压缩带来的性能损耗。
* **灵活的控制选项**: 您可以通过配置强制覆盖后端的缓存策略，或设置规则跳过对某些请求的缓存。

## 使用场景

* **高频读取的 API**：对于那些读取频繁但内容不经常变化的 API（如获取商品列表、文章详情、配置信息等），开启缓存可以带来极大的性能提升。
* **静态与半静态资源**：虽然有专门的静态文件服务插件，但对于那些由后端服务生成的、不常变化的资源（如动态生成的 CSS、头像图片），使用缓存插件同样非常有效。
* **保护后端服务**：在流量洪峰期间，缓存可以作为一道坚固的屏障，吸收绝大部分重复的读取请求，保护后端数据库和服务不被冲垮。
* **降低外部 API 调用成本**：如果您的服务依赖于按次计费的第三方 API，通过缓存其响应可以显著降低调用成本。

## 配置参数

在 `plugins.cache.toml` 文件中进行配置。

| 参数                  | 类型             | 是否必需 | 说明                                                                                                                                                                                     |
| :-------------------- | :--------------- | :------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`directory`**       | String           | 否       | 指定用于存储缓存文件的**磁盘目录**。如果配置了此项，将开启文件缓存，若不配置则为内存缓存。<br />需要注意多个缓存插件均配置为内存缓存，其共享同一个缓存，而缓存的初始化为首次调用的插件。 |
| **`max_size`**        | String           | 否       | 指定**内存缓存**的最大容量，例如 `"128MB"`, `"1GB"`。                                                                                                                                    |
| **`eviction`**        | Boolean          | 否       | 是否启用基于 LRU 算法的**缓存驱逐**机制。通常与 `max_size` 配合使用。                                                                                                                    |
| `max_ttl`             | String           | 否       | **强制**设置缓存的最大有效期（如 `"1h"`, `"10m"`），此配置会**覆盖**上游服务响应头中的 `Cache-Control`。                                                                                 |
| `max_file_size`       | String           | 否       | 允许缓存的单个响应体的最大大小，例如 `"1MB"`。超过此大小的响应将不会被缓存。                                                                                                             |
| `check_cache_control` | Boolean          | 否       | `false`。是否检查 `Cache-Control` 头，如果为 `true` 且响应中无 `Cache-Control` 头，则不缓存。                                                                                            |
| `namespace`           | String           | 否       | 为缓存项指定一个命名空间，用于隔离不同 `Location` 或不同类型的缓存。                                                                                                                     |
| `headers`             | Array of Strings | 否       | 指定一组请求头名称，这些头的值将被纳入缓存键 (Cache Key) 的计算。用于实现多样化缓存 (Vary)。                                                                                             |
| `lock`                | String           | 否       | 启用**缓存击穿防护**，并设置锁的等待超时时间，可选值为 `"1s"`, `"2s"`, `"3s"`。                                                                                                          |
| `purge_ip_list`       | Array of Strings | 否       | 一个 IP 白名单，只有来自这些 IP 的 `PURGE` 请求才被允许清除缓存。                                                                                                                        |
| `skip`                | String           | 否       | 一个正则表达式，匹配请求的 URI。任何匹配成功的请求都将**跳过**缓存逻辑。                                                                                                                 |


directory支持两种形式方式：

- `memory`: 内存缓存，使用内存作为缓存后端，支持LRU驱逐机制，不配置则是内存缓存。格式为`memory://?max_size=100MB`，如果`max_size`不指定则为`256MB`，若设置为`max_size=10`则表示使用可用内存的`10%`初始化内存缓存
- `file`: 文件缓存，使用文件作为缓存后端，可配置热点数据的内存LRU。格式为`/var/cache/pingap/articles?levels=1:2&inactive=7d&reading_max=1000&writing_max=500&cache_max=100&cache_file_max_size=1MB`，参数说明如下：

| 参数 (Parameter)    | 类型 (Type)     | 默认值 (Default) | 说明                                                                                                                                                 |
| :------------------ | :-------------- | :--------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------- |
| levels              | String          | 0                | 设置缓存的子目录层级，默认不设置。这会将缓存文件分散到多层子目录中，避免单个目录下文件过多导致文件系统性能下降。对于高流量缓存，强烈建议设置为 1:2。 |
| inactive            | String          | "48h"            | 非活跃文件清理阈值。如果一个缓存文件在此时间内没有被访问，它将被视为非活跃并可能被清理。格式为时间字符串，如 "7d" (7天), "24h" (24小时)。            |
| reading_max         | Integer         | 1000             | 允许同时读取缓存文件的最大并发数。                                                                                                                   |
| writing_max         | Integer         | 1000             | 允许同时写入缓存文件的最大并发数。                                                                                                                   |
| cache_max           | Integer         | 0                | 内存热点缓存中可以容纳的最大文件数量。这是一个位于内存中的二级缓存 (tinyLFU)，用于存放最热门的小文件，以获得极致的读取性能。                         |
| cache_file_max_size | Integer (Bytes) | 1MB              | 允许进入内存热点缓存的单个文件的最大尺寸。超过此大小的文件将只存储在磁盘上，不会进入内存热点缓存。                                                   |


## 完整示例

**目标**：为 `/api/articles/` 路径下的只读接口开启缓存。
* 使用内存和文件双层缓存。
* 根据客户端是否支持 `gzip` 压缩来存储不同版本的缓存。
* 启用缓存驱逐和缓存击穿保护。
* 只允许内网 IP 清除缓存。

#### 1. 配置插件 (`plugins.cache-articles.toml`)
```toml
# 开启缓存驱逐
eviction = true
# 设置内存缓存上限为 256MB
max_size = "256MB"
# 将文件缓存存储在指定目录
directory = "/var/cache/pingap/articles"

# 将 Accept-Encoding 请求头加入缓存键，以区分 gzip 和非 gzip 的缓存
headers = [
  "Accept-Encoding",
]

# 开启缓存击穿保护，锁等待时间为 2 秒
lock = "2s"

# 强制缓存最长不超过 1 小时
max_ttl = "1h"

# 限制最大缓存 1MB 的文件
max_file_size = "1MB"

# 只允许来自内网的请求清除缓存
purge_ip_list = [
  "127.0.0.1",
  "10.0.0.0/8",
]
```

#### 2. 在 Location 中应用插件 (location.toml)

```toml
# location.toml
[locations.route-for-my-app]
path = "/api/articles/"
upstream = "article-service-backend"
plugins = [
    "cache-articles",
]
```

访问与缓存刷新效果

- 首次访问: GET /api/articles/123
  - 缓存未命中 (Cache Miss)。请求被转发到 article-service-backend。
  - 后端返回的成功响应（并带有可缓存的 Cache-Control 头）将被插件存储到内存和文件中。

- 再次访问: GET /api/articles/123
  - 缓存命中 (Cache Hit)。插件直接从缓存中返回响应，请求不会到达后端服务。

- 清除缓存: PURGE /api/articles/123 (从 10.0.1.10 发起)
  - purge_ip_list 验证通过。
  - /api/articles/123 对应的缓存项被从内存和文件中删除。
  - 下一次对此 URL 的 GET 请求将再次回源。