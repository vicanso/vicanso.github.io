"use strict";(self.webpackChunkpingap=self.webpackChunkpingap||[]).push([[9387],{7714:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"question","title":"Frequently Asked Questions (FAQ)","description":"This section gathers some of the most common questions and their solutions that users encounter while using Pingap.","source":"@site/docs/question.md","sourceDirName":".","slug":"/question","permalink":"/pingap-en/docs/question","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/question.md","tags":[],"version":"current","sidebarPosition":151,"frontMatter":{"sidebar_position":151},"sidebar":"tutorialSidebar","previous":{"title":"Deploying Pingap with Docker","permalink":"/pingap-en/docs/docker"},"next":{"title":"Performance Testing","permalink":"/pingap-en/docs/performance"}}');var t=s(4848),r=s(8453);const o={sidebar_position:151},c="Frequently Asked Questions (FAQ)",d={},a=[{value:"Q: I have multiple services using the same port. Why is the routing incorrect when I access them via domain names?",id:"q-i-have-multiple-services-using-the-same-port-why-is-the-routing-incorrect-when-i-access-them-via-domain-names",level:4},{value:"Q: I updated the <code>DNS</code> record for my domain. Why isn&#39;t <code>Pingap</code> forwarding to the new <code>IP</code> address?",id:"q-i-updated-the-dns-record-for-my-domain-why-isnt-pingap-forwarding-to-the-new-ip-address",level:4},{value:"Q: How do I configure the number of threads for <code>Pingap</code>? How does it work?",id:"q-how-do-i-configure-the-number-of-threads-for-pingap-how-does-it-work",level:4},{value:"Q: What should I be aware of when my backend service (Upstream) uses the HTTPS protocol?",id:"q-what-should-i-be-aware-of-when-my-backend-service-upstream-uses-the-https-protocol",level:4},{value:"Q: How can I serve multiple different domains over HTTPS on the same port?",id:"q-how-can-i-serve-multiple-different-domains-over-https-on-the-same-port",level:4},{value:"Q: My service is deployed on multiple IPs. How do I prevent all instances from trying to apply for a <code>Let&#39;s Encrypt</code> certificate?",id:"q-my-service-is-deployed-on-multiple-ips-how-do-i-prevent-all-instances-from-trying-to-apply-for-a-lets-encrypt-certificate",level:4}];function l(e){const n={code:"code",h1:"h1",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"frequently-asked-questions-faq",children:"Frequently Asked Questions (FAQ)"})}),"\n",(0,t.jsxs)(n.p,{children:["This section gathers some of the most common questions and their solutions that users encounter while using ",(0,t.jsx)(n.code,{children:"Pingap"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"q-i-have-multiple-services-using-the-same-port-why-is-the-routing-incorrect-when-i-access-them-via-domain-names",children:"Q: I have multiple services using the same port. Why is the routing incorrect when I access them via domain names?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"A"}),": This is because when multiple services share the same IP and port, ",(0,t.jsx)(n.code,{children:"Pingap"})," needs to rely on the ",(0,t.jsx)(n.code,{children:"Host"})," field in the request header to differentiate and forward requests to the correct backend. By default, ",(0,t.jsx)(n.code,{children:"Pingap"})," passes the client's original ",(0,t.jsx)(n.code,{children:"Host"})," header directly to the backend."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),": If your upstream service also needs to process requests based on the ",(0,t.jsx)(n.code,{children:"Host"})," header, you must explicitly set the ",(0,t.jsx)(n.code,{children:"Host"})," to the domain name your backend service expects in the ",(0,t.jsxs)(n.strong,{children:["Set Forwarded Request Headers (",(0,t.jsx)(n.code,{children:"proxy_set_headers"}),")"]})," option within the ",(0,t.jsx)(n.strong,{children:"Location configuration"}),"."]}),"\n",(0,t.jsxs)(n.h4,{id:"q-i-updated-the-dns-record-for-my-domain-why-isnt-pingap-forwarding-to-the-new-ip-address",children:["Q: I updated the ",(0,t.jsx)(n.code,{children:"DNS"})," record for my domain. Why isn't ",(0,t.jsx)(n.code,{children:"Pingap"})," forwarding to the new ",(0,t.jsx)(n.code,{children:"IP"})," address?"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"A"}),": When handling ",(0,t.jsx)(n.code,{children:"Upstream"})," addresses configured as domain names, ",(0,t.jsx)(n.code,{children:"Pingap"}),"'s default service discovery mechanism only performs a ",(0,t.jsx)(n.code,{children:"DNS"})," resolution once at startup. If it resolves to multiple ",(0,t.jsx)(n.code,{children:"IPs"}),", they will all be added as nodes, but any subsequent changes to the ",(0,t.jsx)(n.code,{children:"DNS"})," record will not be automatically detected."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),": If your upstream service's ",(0,t.jsx)(n.code,{children:"IP"})," address changes dynamically (e.g., in a cloud environment or Kubernetes), you should configure ",(0,t.jsx)(n.code,{children:"DNS"})," service discovery for that ",(0,t.jsx)(n.code,{children:"Upstream"}),". To do this, add ",(0,t.jsx)(n.code,{children:'discovery = "dns"'})," and set a reasonable ",(0,t.jsx)(n.code,{children:"update_frequency"})," (e.g., ",(0,t.jsx)(n.code,{children:"30s"}),") in the ",(0,t.jsx)(n.code,{children:"Upstream"})," configuration."]}),"\n",(0,t.jsxs)(n.h4,{id:"q-how-do-i-configure-the-number-of-threads-for-pingap-how-does-it-work",children:["Q: How do I configure the number of threads for ",(0,t.jsx)(n.code,{children:"Pingap"}),"? How does it work?"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"A"}),": The number of worker threads in ",(0,t.jsx)(n.code,{children:"Pingap"})," can be finely controlled, with the following configuration priority:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Server-level configuration"}),": The ",(0,t.jsx)(n.code,{children:"threads"})," value set for a specific service in ",(0,t.jsx)(n.code,{children:"server.toml"})," has the highest priority."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Global basic configuration"}),": The ",(0,t.jsx)(n.code,{children:"threads"})," value set in ",(0,t.jsx)(n.code,{children:"basic.toml"})," serves as the default for all ",(0,t.jsx)(n.code,{children:"Server"}),"s that do not have their own thread count configured."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Program default"}),": If neither of the above is configured, it defaults to ",(0,t.jsx)(n.code,{children:"1"})," thread."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Additionally, setting ",(0,t.jsx)(n.code,{children:"threads"})," to ",(0,t.jsx)(n.code,{children:"0"})," is a special mode that tells ",(0,t.jsx)(n.code,{children:"Pingap"})," to automatically set the number of threads equal to the number of ",(0,t.jsx)(n.code,{children:"CPU"})," cores in the current environment."]}),"\n",(0,t.jsx)(n.h4,{id:"q-what-should-i-be-aware-of-when-my-backend-service-upstream-uses-the-https-protocol",children:"Q: What should I be aware of when my backend service (Upstream) uses the HTTPS protocol?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"A"}),": When you configure an ",(0,t.jsx)(n.code,{children:"Upstream"})," that uses HTTPS, please ensure you complete the following two key configurations:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Set SNI"}),": You must correctly fill in the ",(0,t.jsx)(n.code,{children:"sni"})," field in the ",(0,t.jsx)(n.code,{children:"Upstream"})," configuration. Its value is typically the domain name of your backend service. This is crucial for a successful TLS handshake."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Port"}),": If your backend service uses the standard ",(0,t.jsx)(n.code,{children:"443"})," port, you can omit the port number; otherwise, be sure to specify the port explicitly in ",(0,t.jsx)(n.code,{children:"addrs"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If you are using a self-signed certificate, set the certificate verification option to ",(0,t.jsx)(n.code,{children:"No"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"q-how-can-i-serve-multiple-different-domains-over-https-on-the-same-port",children:"Q: How can I serve multiple different domains over HTTPS on the same port?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"A"}),": ",(0,t.jsx)(n.code,{children:"Pingap"})," supports multi-domain ",(0,t.jsx)(n.code,{children:"HTTPS"})," services based on ",(0,t.jsx)(n.code,{children:"SNI"}),", and the configuration is very simple:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Add all certificates"}),": In the ",(0,t.jsx)(n.strong,{children:"Certificate Management"})," interface, upload or apply for the corresponding ",(0,t.jsx)(n.code,{children:"HTTPS"})," certificates for all the domains you need to support."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Enable global certificates"}),": In the ",(0,t.jsx)(n.code,{children:"server.toml"})," configuration file, find the ",(0,t.jsx)(n.code,{children:"Server"})," that provides ",(0,t.jsx)(n.code,{children:"HTTPS"})," services and make sure the ",(0,t.jsxs)(n.strong,{children:["Enable Global Certificate Configuration (",(0,t.jsx)(n.code,{children:"global_certificates"}),")"]})," option is checked."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["After completing these two steps, ",(0,t.jsx)(n.code,{children:"Pingap"})," will automatically select and provide the correct certificate based on the domain name requested by the client during the ",(0,t.jsx)(n.code,{children:"TLS"})," connection."]}),"\n",(0,t.jsxs)(n.h4,{id:"q-my-service-is-deployed-on-multiple-ips-how-do-i-prevent-all-instances-from-trying-to-apply-for-a-lets-encrypt-certificate",children:["Q: My service is deployed on multiple IPs. How do I prevent all instances from trying to apply for a ",(0,t.jsx)(n.code,{children:"Let's Encrypt"})," certificate?"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"A"}),": This is a very typical multi-node deployment scenario. When a domain name resolves to multiple IP addresses (corresponding to multiple ",(0,t.jsx)(n.code,{children:"Pingap"})," instances), you must ensure that only one instance is responsible for the ",(0,t.jsx)(n.code,{children:"ACME"})," certificate application and renewal. If all instances try to apply, you will quickly hit ",(0,t.jsx)(n.code,{children:"Let's Encrypt"}),"'s rate limits, and it may lead to application failure due to validation conflicts."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),": On all ",(0,t.jsx)(n.code,{children:"Pingap"})," instances except for the primary one, disable the ",(0,t.jsx)(n.code,{children:"ACME"})," feature by setting an environment variable."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"PINGAP_DISABLE_ACME=true\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This way, only the primary instance will handle certificate matters, while the other instances will wait for and share the certificate obtained by the primary instance (usually achieved through shared storage or a configuration center). It is recommended that only one instance be responsible for applying for certificates, regardless of whether you are using the ",(0,t.jsx)(n.code,{children:"http-01 challenge"})," or the ",(0,t.jsx)(n.code,{children:"dns-01 challenge"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var i=s(6540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);