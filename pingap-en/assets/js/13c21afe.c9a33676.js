"use strict";(self.webpackChunkpingap=self.webpackChunkpingap||[]).push([[2757],{7923:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"plugin","title":"Plugin System","description":"Plugins are the core extension mechanism of Pingap. By attaching a series of plugins to a Location, you can implement a wide range of complex functionalities such as authentication, rate limiting, caching, content modification, and observability, flexibly customizing the request and response processing flow.","source":"@site/docs/plugin.md","sourceDirName":".","slug":"/plugin","permalink":"/pingap-en/docs/plugin","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/plugin.md","tags":[],"version":"current","sidebarPosition":71,"frontMatter":{"sidebar_position":71},"sidebar":"tutorialSidebar","previous":{"title":"Easily Manage HTTPS Certificates","permalink":"/pingap-en/docs/certificate"},"next":{"title":"Plugin Overview and Index","permalink":"/pingap-en/docs/plugins/"}}');var t=s(4848),r=s(8453);const l={sidebar_position:71},o="Plugin System",d={},a=[{value:"Core Concept: The Request Processing Lifecycle",id:"core-concept-the-request-processing-lifecycle",level:2},{value:"Plugin Execution Points and Methods",id:"plugin-execution-points-and-methods",level:3},{value:"1. Request Handling Phase (<code>handle_request</code>)",id:"1-request-handling-phase-handle_request",level:4},{value:"2. Upstream Response Handling Phase (<code>handle_upstream_response</code> / <code>handle_upstream_response_body</code>)",id:"2-upstream-response-handling-phase-handle_upstream_response--handle_upstream_response_body",level:4},{value:"3. Client Response Handling Phase (<code>handle_response</code> / <code>handle_response_body</code>)",id:"3-client-response-handling-phase-handle_response--handle_response_body",level:4},{value:"The <code>Plugin</code> Trait Explained",id:"the-plugin-trait-explained",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"plugin-system",children:"Plugin System"})}),"\n",(0,t.jsxs)(n.p,{children:["Plugins are the core extension mechanism of ",(0,t.jsx)(n.code,{children:"Pingap"}),". By attaching a series of plugins to a ",(0,t.jsx)(n.code,{children:"Location"}),", you can implement a wide range of complex functionalities such as authentication, rate limiting, caching, content modification, and observability, flexibly customizing the request and response processing flow."]}),"\n",(0,t.jsx)(n.h2,{id:"core-concept-the-request-processing-lifecycle",children:"Core Concept: The Request Processing Lifecycle"}),"\n",(0,t.jsxs)(n.p,{children:["To understand how plugins work, you first need to understand the complete lifecycle of a request within ",(0,t.jsx)(n.code,{children:"Pingap"}),". The new plugin system allows you to attach logic at several key nodes (Hooks) in the lifecycle."]}),"\n",(0,t.jsx)(n.p,{children:"Below is a simplified flowchart of the request processing:"}),"\n",(0,t.jsx)(n.mermaid,{value:'graph TD\n    A(Client Request) --\x3e B{Request Handling Phase};\n    B -- Execute handle_request --\x3e B1(Plugin Logic);\n    B1 -- Can respond directly --\x3e F(Client Response);\n    B1 -- Continue processing --\x3e C{Forward to Upstream};\n    C --\x3e D{Upstream Response Handling Phase};\n    D -- Execute handle_upstream_response / response_body --\x3e D1(Plugin Logic);\n    D1 --\x3e E{Client Response Handling Phase};\n    E -- Execute handle_response / response_body --\x3e E1(Plugin Logic);\n    E1 --\x3e F;\n\n    subgraph "Inside Pingap"\n        direction LR\n        B\n        C\n        D\n        E\n    end'}),"\n",(0,t.jsx)(n.p,{children:"As shown in the diagram, plugins can primarily operate within three major phases, each of which is further divided into handling the Header and the Body."}),"\n",(0,t.jsx)(n.h3,{id:"plugin-execution-points-and-methods",children:"Plugin Execution Points and Methods"}),"\n",(0,t.jsxs)(n.p,{children:["A plugin can implement multiple methods from the ",(0,t.jsx)(n.code,{children:"Plugin"})," trait to execute specific logic at different nodes of the lifecycle."]}),"\n",(0,t.jsxs)(n.h4,{id:"1-request-handling-phase-handle_request",children:["1. Request Handling Phase (",(0,t.jsx)(n.code,{children:"handle_request"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["This is the first point at which a plugin can intervene, before ",(0,t.jsx)(n.code,{children:"Pingap"})," routes the request and forwards it to the upstream service."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"When is it called?"}),": At the very beginning of request processing."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Primary Uses?"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Access Control"}),": Such as IP blacklists/whitelists, API key authentication, JWT validation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Request Modification"}),": Adding, removing, or modifying request headers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Traffic Control"}),": Request rate limiting."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Short-circuiting Requests"}),": Directly returning a response without accessing the backend (e.g., returning mock data, a maintenance page, or a redirect)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Key Return Value (",(0,t.jsx)(n.code,{children:"RequestPluginResult"}),")"]}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Continue"}),": The request, after being processed or modified by the plugin, continues to the next step in the flow."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Respond"}),": Interrupts the current request and immediately sends a response generated by the plugin back to the client."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"2-upstream-response-handling-phase-handle_upstream_response--handle_upstream_response_body",children:["2. Upstream Response Handling Phase (",(0,t.jsx)(n.code,{children:"handle_upstream_response"})," / ",(0,t.jsx)(n.code,{children:"handle_upstream_response_body"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"After Pingap receives a response from the backend Upstream, plugins can intervene in this phase before it is cached or otherwise processed."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"When is it called?"}),": Immediately after receiving the upstream response, but before it is written to any cache."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Primary Uses?"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Inspecting Original Response"}),': Logging or analyzing the "rawest" response headers and body from the backend.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Early Response Modification"}),": Modifying the response header or body before it is used by other modules (like the cache)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Related Methods"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"handle_upstream_response"}),": Handles the upstream response's Header."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"handle_upstream_response_body"}),": Processes the upstream response's Body chunks in a streaming fashion."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"3-client-response-handling-phase-handle_response--handle_response_body",children:["3. Client Response Handling Phase (",(0,t.jsx)(n.code,{children:"handle_response"})," / ",(0,t.jsx)(n.code,{children:"handle_response_body"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"This is the final point at which a plugin can intervene, before Pingap prepares to send the final response to the client."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"When is it called?"}),": After all internal processing is complete (including fetching a response from the cache), but before it is sent to the client."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Primary Uses?"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Final Content Modification"}),": Injecting analytics scripts into HTML pages, uniformly modifying the structure of JSON responses, performing find-and-replace on the response body."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Adding Common Response Headers"}),": Adding custom response headers like ",(0,t.jsx)(n.code,{children:"Server-Timing"})," or ",(0,t.jsx)(n.code,{children:"X-Trace-Id"})," to all responses."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Response Compression/Decompression"}),": Implementing custom compression logic."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Related Methods and Return Values"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"handle_response"}),": Handles the final response's Header."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"handle_response_body"}),": Processes the final response's Body in a streaming fashion."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Key Return Value (",(0,t.jsx)(n.code,{children:"ResponseBodyPluginResult"}),")"]}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PartialReplaced"}),": Replaces the currently received Body data chunk."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"FullyReplaced"}),": Replaces the entire response body with a completely new one."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"the-plugin-trait-explained",children:["The ",(0,t.jsx)(n.code,{children:"Plugin"})," Trait Explained"]}),"\n",(0,t.jsxs)(n.p,{children:["Below is the definition of the ",(0,t.jsx)(n.code,{children:"Plugin"})," trait that developers need to implement when creating custom plugins. It clearly shows all the available lifecycle hooks."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'/// Core trait that defines the interface all plugins must implement.\n#[async_trait]\npub trait Plugin: Sync + Send {\n    /// Returns a unique key that identifies this specific plugin instance.\n    fn config_key(&self) -> Cow<\'_, str> {\n        Cow::Borrowed("")\n    }\n\n    /// Processes an HTTP request at a specified lifecycle step.\n    #[inline]\n    async fn handle_request(\n        &self,\n        _step: PluginStep,\n        _session: &mut Session,\n        _ctx: &mut Ctx,\n    ) -> pingora::Result<RequestPluginResult> {\n        Ok(RequestPluginResult::Skipped)\n    }\n    \n    /// Processes an upstream response header at a specified lifecycle step.\n    #[inline]\n    fn handle_upstream_response(\n        &self,\n        _session: &mut Session,\n        _ctx: &mut Ctx,\n        _upstream_response: &mut ResponseHeader,\n    ) -> pingora::Result<ResponsePluginResult> {\n        Ok(ResponsePluginResult::Unchanged)\n    }\n\n    /// Processes an upstream response body chunk at a specified lifecycle step.\n    #[inline]\n    fn handle_upstream_response_body(\n        &self,\n        _session: &mut Session,\n        _ctx: &mut Ctx,\n        _body: &mut Option<bytes::Bytes>,\n        _end_of_stream: bool,\n    ) -> pingora::Result<ResponseBodyPluginResult> {\n        Ok(ResponseBodyPluginResult::Unchanged)\n    }\n\n    /// Processes the final HTTP response header before sending to the client.\n    #[inline]\n    async fn handle_response(\n        &self,\n        _session: &mut Session,\n        _ctx: &mut Ctx,\n        _upstream_response: &mut ResponseHeader,\n    ) -> pingora::Result<ResponsePluginResult> {\n        Ok(ResponsePluginResult::Unchanged)\n    }\n\n    /// Processes the final HTTP response body chunk before sending to the client.\n    #[inline]\n    fn handle_response_body(\n        &self,\n        _session: &mut Session,\n        _ctx: &mut Ctx,\n        _body: &mut Option<bytes::Bytes>,\n        _end_of_stream: bool,\n    ) -> pingora::TResult<ResponseBodyPluginResult> {\n        Ok(ResponseBodyPluginResult::Unchanged)\n    }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var i=s(6540);const t={},r=i.createContext(t);function l(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);